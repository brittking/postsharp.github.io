---
layout: post 
comments: true
title: "Announcing PostSharp 2.1 CTP 2"
date: 2011-05-26 21:09:19 +02:00
permalink: /post/announcing-postsharp-21-ctp-2.html
author: "Gael Fraiteur"
---
<p>I’m excited to announce the release of PostSharp 2.1 CTP 2, available for download <a href="http://www.sharpcrafters.com/downloads/postsharp-2.1/ctp-2" target="_blank">from our web site</a> and from the <a href="http://www.nuget.org/List/Packages/PostSharp" target="_blank">NuGet gallery</a>. This CTP is mostly feature complete and has zero known bugs. It includes all fixes from the 2.0 branch.</p>


  <p>If you’re not on a tight go-to-production schedule, it’s pretty safe to give this version a try now. Unlike with the previous CTP, we will be in “continuous delivery” mode and will be able to release hot fixes very quickly.</p>  <p>So what’s new in PostSharp 2.1? I’ll be blogging about individual features the next days. Here is a short summary:</p>  <ul>   <li>Build-time performance improvement </li>    <li>NuGet packaging and improved no-setup experience </li>    <li>Extensions to the System.Reflection API </li>    <li>Architecture validation (constraints) </li>    <li>Support for obfuscation </li>    <li>Support for Silverlight 5 </li>    <li>License management </li> </ul>  <h2>Build-Time Performance Improvement</h2>  <p>Most users will see <em>some</em> improvement in the build-time performance of PostSharp, but for some users it could even mean a 500% speed up. The main reason? We completely rewrote the last step of the PostSharp pipeline: writing the modified assembly back to disk. The previous implementation was based on ILASM, which scaled badly for very large assemblies. The new implementation is fully written in unsafe C# and is probably the fastest available. Other improvements are due to a better utilization of multiple cores, although PostSharp remains largely a single-threaded program. For details about this feature, see our <a href="http://www.sharpcrafters.com/blog/post/Announcing-PostSharp-21-CTP-1.aspx" target="_blank">CTP 1 announcement</a>.</p>  <p>This feature is available on all editions of PostSharp.</p>  <h2>NuGet Package and Improved No-Setup Experience</h2>  <p>PostSharp 2.1 can now be added to your application directly from Visual Studio thanks to NuGet. No need to run a program with elevated privileges. No need to edit your project file if you want to put PostSharp in your source repository. Everything is done by the NuGet package installer.</p>  <p>You can now use the Visual Studio Extension (VSX) even if you don’t want to run the setup program. The first time you (or your colleague) will build a program using PostSharp, a dialog box will ask you whether you want to install the VSX. No elevated privileges needed. When you deploy a new version of PostSharp to the source control, all developers get the updated VSX.</p>  <p>Thanks to NuGet, it will become much easier for vendors and open-source projects to include a dependency to PostSharp. Our friends at <a href="http://www.gibraltarsoftware.com/" target="_blank">Gibraltar Software</a> already uploaded their application <a href="http://www.nuget.org/List/Packages/Gibraltar.Agent.PostSharp" target="_blank">monitoring agent</a>, and will soon update it to include the dependency to the PostSharp package. </p>  <p>This feature is available on all editions of PostSharp.</p>  <h2>Extensions to the System.Reflection API</h2>  <p>How many times did you want to get the list of all classes in your assembly deriving from System.Forms.Control? Sure, you can enumerate all types and build the index yourself, but it’s quite CPU expensive. Since PostSharp already computes this information internally, it seemed natural to expose it to the <em>PostSharp.dll</em> library. The <em>PostSharp.Reflection.ReflectionSearch</em> class offers methods that allow you to search for:</p>  <ul>   <li>All custom attributes of a given type (or derived type); </li>    <li>All custom attributes on a given declaration (including those added through MulticastAttribute); </li>    <li>All types derived from a given class or implementing a given interface; </li>    <li>All methods, fields or types referenced in the body of a given method; </li>    <li>All methods using a given method, field or type in their body; </li>    <li>All types, methods, fields, properties, events or parameters referencing a given type. </li> </ul>  <p>Note that this functionality is only available at build time. This feature is available on the Professional Edition only.</p>  <h2>Architecture Validation (Constraints)</h2>  <p>Many people used “empty” aspects that just did one thing: validate the code. You now have a better way to validate your code: constraints (namespace PostSharp.Constraints). As aspects, constraints are custom attributes that you put on your code. They contain code that gets executed for every assembly referencing this code. The constraint logic typically queries the current assembly using reflection and the newly introduced reflection extensions, and emit errors or warnings to Visual Studio. Since your code can use LINQ, you have a very powerful toy to play with! PostSharp comes with off-the-self constraints:</p>  <ul>   <li>[Friend], applied to an internal declaration, will raise an error if the declaration is used in a different namespace than the current one. It can be used to enforce isolation of components, and gives a level of visibility that stands between <em>private</em> and <em>internal</em>. </li>    <li>[InternalImplements], applied on public interfaces, will raise an error if the interface is implemented in a different assembly. Use this constraint when you need to expose an interface but don’t want the users of your API to implement it, because you want to reserve the right to add new methods to the interface. PostSharp SDK is full of such interfaces that can be consumed but not implemented. </li>    <li>[Internal], applied on a public declaration, will raise an error if the declaration is used in a third assembly. It can be used when you don’t want users to reference a part of the API, but have to make it public for technical reasons. </li> </ul>  <p>Note that architecture validation is disabled by default. You need to enable it in your project properties (“PostSharp” property page). This feature is available on the Professional Edition only.</p>  <h2>Support for Obfuscation</h2>  <p>Let me start with a disambiguation: PostSharp does <em>not</em> become an obfuscator with this feature. It just became compatible with some obfuscators.</p>  <p>In previous versions, you could get into serious problems if you tried to use PostSharp and any obfuscator in the same project. PostSharp relied on some metadata references that were broken by the obfuscator because of renaming, so you got runtime exceptions. This is obvious if, for instance, you had a field of type MethodInfo in your aspect. The method name was stored in the serialization stream and the obfuscator did not know how to modify it. There were other less obvious cases with aspects on generic methods.</p>  <p>PostSharp 2.1 can be made aware of obfuscators and write metadata references in a way that obfuscators can understand and modify. But the obfuscator has also to be aware of PostSharp.</p>  <p>We implemented support for <a href="http://www.preemptive.com/products/dotfuscator/overview" target="_blank">Dotfuscator</a> because it is the market leader and has a free edition that ships with Visual Studio. According to the feedback we get from this CTP, we will publish our specification so that other vendors can implement it if they are interested.</p>  <p>This feature is available on the Professional Edition only.</p>  <h2></h2>  <h2>Support for Silverlight 5 Beta</h2>  <p>PostSharp 2.1 supports Silverlight 5 applications. What to add? This feature is available on all editions.</p>  <h2>License Management</h2>  <p>First of all, we chose to rename the community edition to <strong>Starter Edition</strong>. We got too many questions whether the community edition can be used for commercial project. We hope the new name makes the answer clear: yes, you can use the Starter Edition in commercial projects, you will just enjoy less features than with the Professional Edition.</p>  <p>At SharpCrafters, our license enforcement policy is to trust the customer to respect the license agreement. That’s why there was no license enforcement in version 2.0. It was not just a priority. But we may have been too liberal by letting people deploy the license key in the source control: for many companies, it meant that nobody knew how many developers were using the product. We strongly believe in trust, but we think that we should provide tools for proper license management. So we did a few changes.</p>  <p>We chose to deprecate deployment of license keys through source control because we want some mental process to take place when a developer first starts using the product: he also needs a license. We provide a license metering solution: we will monitor how many people install the license on their computer, but we will never block them. If we that believe a license key is being used too many times, we will simply contact the one who purchased the license key and discuss a solution. But we trust you in first place. By requesting license installation by each user, we are just asking that every company maintains a record of who is using the software.</p>  <p>What if manual license bookkeeping is impractical? For these situations, we provide a license server (technically: a simple ASP.NET application backed by an SQL database). The license server maintains the list of leases and ensures that the license agreement is respected. It will send emails to the license administrator (or team leader, or whomever else) when new licenses should be acquired – and you will get a 30-day grace period to purchase them. We tried to make the license server a valuable tool <em>for the customer</em>. You are free to modify the underlying database at will if it makes sense. You as the customer are responsible for respecting the legal agreement and we trust you.</p>  <p>The license server will be available with a new type of licenses called <em>corporate licenses</em>, that will be available for a premium (likely +30% compared to the normal commercial license).</p>  <h2>Upgrade Today</h2>  <p>The upgrade is free for anyone. I am pretty confident of the quality of this release so it’s a great time for you to <a href="http://www.sharpcrafters.com/downloads/postsharp-2.1/ctp-2" target="_blank">download it</a>. Submit all your changes to source control, do the upgrade, rebuild, and run your unit tests. If it fails, shelve the changes and <a href="http://www.sharpcrafters.com/forum" target="_blank">report the issue</a>. We do a lot of internal testing, but we need your feedback to move quality of this release forward. </p>  <p>In the next days, I’ll try to blog about individual features of this release.</p>  <p>Happy PostSharping!</p>
