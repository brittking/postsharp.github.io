---
layout: post 
comments: true
title: "Announcing PostSharp 3.1 Preview"
date: 2013-10-31 15:55:00 +01:00
permalink: /post/announcing-postsharp-31-preview.html
author: "Gael Fraiteur"
---
<p>Today we’re excited to announce the public availability of PostSharp 3.1 Preview. You can download the new Visual Studio tooling from our website, our update your packages using NuGet Package Manager. In the latter case, make sure to enable the “Include Prereleases” option.</p>


  <p>PostSharp 3.1 includes the following features:</p>  <ul>   <li>Support for state machines (async and iterators)</li>    <li>Improved build performance</li>    <li>Resolution of file and line of error messages</li>    <li>Solution-level policies (and a smarter configuration system)</li>    <li>Indentation in logging</li> </ul>  <p>PostSharp 3.1 is a free upgrade for all customers with a valid support subscription. The license key of PostSharp 3.0 will work.</p>  <h2>Support for state machines</h2>  <p>When you applied an OnMethodBoundaryAspect to a method that was compiled into a state machine, whether an iterator or an async method, the code generated by PostSharp would not be very useful:&#160; the aspect would just be applied to the method that implements the state machine. An OnException advise had no chance to get ever fired.</p>  <p>PostSharp 3.1 gets much smarter. OnMethodBoundaryAspect now understands that is being applied to a state machine, and works as you would expect. To enable the new behavior, you need to set the <em>OnMethodBoundaryAspect.ApplyToStateMachine</em> property to <em>true</em>. It is false by default for backward compatibility.</p>  <p>But there is more: the aspects define two advises: <em>OnYield</em> and <em>OnResume</em>. For the sake of backward compatibility, we could not add them to the <em>IOnMethodBoundaryAspect</em> interface, so we defined a new interface <em>IOnStateMachineBoundaryAspect</em> with these two methods.</p>  <p>More blogging about this later.</p>  <p>To discover more on your own, try to apply the following aspect to an async method or an iterator:</p>  <pre>[Serializable]
public class MyAspect : OnMethodBoundaryAspect, IOnStateMachineBoundaryAspect
{
    public static StringBuilder Trace = new StringBuilder();

    public override void OnEntry(MethodExecutionArgs args)
    {
        Console.WriteLine(&quot;OnEntry&quot;);
    }

    public void OnResume(MethodExecutionArgs args)
    {
        Console.WriteLine(&quot;OnResume&quot;);
    }

    public void OnYield(MethodExecutionArgs args)
    {
        Console.WriteLine(&quot;OnYield&quot;);
    }

    public override void OnSuccess(MethodExecutionArgs args)
    {
        Console.WriteLine(&quot;OnSuccess&quot;);
    }

    public override void OnExit(MethodExecutionArgs args)
    {
        Console.WriteLine(&quot;OnExit&quot;);
    }
}
</pre>

<p><a href="http://www.postsharp.net/blog/post/New-in-PostSharp-31-Support-for-async-and-iterator-methods" target="_blank">Read more about this feature</a>.</p>

<h2>Improved build performance</h2>

<p>The first time you compile a project using a specific build of PostSharp, you will be proposed to install itself into GAC and create native images.</p>

<p><img alt="" src="/assets/images/blog/2013-10-31-announcing_postsharp_31_preview/nativeinstall.png"></p>

<p>Doing will decrease build time of a fraction of a second for each project. A potentially substantial gain if you have a lot of projects. You can uninstall these images at any time from PostSharp options in Visual Studio.</p>

<p>Under the cover, PostSharp will just install itself in GAC using <em>gacutil</em> and will generate native images using <em>ngen</em>.&#160; The feature does not affect build servers or cloud builds, so only build time on developers’ workstations will be improved.</p>

<p>Keep in mind that your end-users will <em>not</em> have PostSharp installed in GAC, so you still need to distribute <em>PostSharp.dll</em>.</p>

<h2>Resolution of file and line of error messages</h2>

<p>When previous versions of PostSharp had to report an error or a warning, it would include the name of the type and/or method causing the message, but was unable to determine the file and line number.</p>

<p>You can now double-click on an error message in Visual Studio and you’ll get to the relevant location for the error message.</p>

<p><img alt="" src="/assets/images/blog/2013-10-31-announcing_postsharp_31_preview/errorlocation.png"></p>

<p>I know, it seems like an obvious feature. But it was actually quite complex to implement. PostSharp works as MSIL level and the file that’s supposed to MSIL back to source – the PDB file – won’t tell you where a type, field, or abstract method is implemented. Indeed, it only contains “sequence points”, mapping instructions to lines of code. That is, only the inside of method bodies are mapped to source code.&#160; So, we had to rely on a source code parser to make the missing like ourselves.</p>

<p>This feature is available for the C# language only.</p>

<p>Note that this feature is not yet fully stable. There are still many situations where locations cannot be resolved.</p>

<h1>Solution-Level Policies</h1>

<p>We made it easier to add a policy to a whole solution. Say you want to add logging to the whole solution. Previously, you had to add the aspect to every project of the solution. Now, you can right-click on the solution and just add it to the solution.</p>

<p><img alt="" src="/assets/images/blog/2013-10-31-announcing_postsharp_31_preview/solutionlevelpolicy.png"></p>

<p>This is not just a UI tweak. To make this scenario possible, we had to do significant work on our configuration subsystem:</p>

<ul>
  <li>Support for solution-level configuration files (<em>SolutionName.pssln</em>), additionally to project-level files (<em>ProjectName.psproj</em>).</li>

  <li>Support for conditional configuration elements.</li>

  <li>Support for XPath in expressions (instead of only property references as previously).</li>
</ul>

<p>Thanks to this improvements, you can add not only our own ready-made aspects to the whole solution, but also your own aspects.</p>

<p>The configuration subsystem is currently largely undocumented and there was not a good use case for it until PostSharp 3.0. I’ll blog further about this feature and we’ll update the documentation.</p>

<p><a href="http://www.postsharp.net/blog/post/New-in-PostSharp-31-Solution-Level-Aspects-and-PostSharp-Configuration-Files" target="_blank">Read more about support for solution-level policies.</a></p>

<h2>Indentation in logging</h2>

<p>PostSharp Diagnostics Pattern Library was good at adding a lot of logging, but the log quickly became unreadable because the output was not indented. We fixed that. If the logging back-end supports indentation, we’ll call its Indent or Unindent method. Otherwise, we’ll create indentation using spaces.</p>

<p><img alt="" src="/assets/images/blog/2013-10-31-announcing_postsharp_31_preview/indentation.png"></p>

<p>Our implementation is thread-safe and still does not require you to add a reference to any PostSharp library at runtime (the reference is required at build time and will be removed).</p>

<h2>Improvements in PostSharp 3.0</h2>

<p>Note that while working on PostSharp 3.1, we still added some features to PostSharp 3.0. The most important ones are support for Windows 8.1 and Visual Studio 2013. Keeping in pace with changes of development environments is a challenge in itself, and we’re glad this we handled it smoothly, without forcing customers to wait for a new minor version.</p>

<p>Please report any issue on our support forum. We’d love to hear about your feedback.</p>

<p>Happy PostSharping – faster than ever.</p>

<p>-gael</p>
